// server.js
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');
const cors = require('cors');

const app = express();
app.use(cors());
const server = http.createServer(app);
const io = socketIO(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

io.on('connection', (socket) => {
  socket.on('join-room', (roomId, userId) => {
    socket.join(roomId);
    socket.broadcast.to(roomId).emit('user-connected', userId);

    socket.on('disconnect', () => {
      socket.broadcast.to(roomId).emit('user-disconnected', userId);
    });

    socket.on('gesture', (gesture) => {
      socket.broadcast.to(roomId).emit('gesture-received', gesture);
    });
  });
});

server.listen(3000, () => {
  console.log('Server running on port 3000');
});

// index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Chat with Gestures</title>
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f2f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .video-wrapper {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        video {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #0066ff;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #0052cc;
        }
        .gesture-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-grid">
            <div class="video-wrapper">
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div class="video-wrapper">
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
        <div class="controls">
            <button id="startButton">Start Call</button>
            <button id="muteButton">Mute</button>
            <button id="videoButton">Video Off</button>
        </div>
    </div>
    <div class="gesture-indicator" id="gestureIndicator"></div>
    <script src="client.js"></script>
</body>
</html>

// client.js
let localStream;
let remoteStream;
let peerConnection;
let socket;
let hands;
let roomId = 'default-room';
let userId = Math.random().toString(36).substr(2, 9);

const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        {
            urls: 'turn:your-turn-server.com',
            username: 'username',
            credential: 'password'
        }
    ]
};

// Initialize MediaPipe Hands
async function initializeHandTracking() {
    hands = new Hands({
        locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
    });

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandsResults);
}

// Process hand tracking results
function onHandsResults(results) {
    if (results.multiHandLandmarks) {
        const gesture = detectGesture(results.multiHandLandmarks[0]);
        if (gesture) {
            socket.emit('gesture', gesture);
            showGestureIndicator(gesture);
        }
    }
}

// Detect gestures based on hand landmarks
function detectGesture(landmarks) {
    if (!landmarks) return null;

    // Thumb up detection
    const thumbTip = landmarks[4];
    const thumbBase = landmarks[2];
    if (thumbTip.y < thumbBase.y) {
        return 'thumbs-up';
    }

    // Wave detection
    const wristY = landmarks[0].y;
    const fingertipsY = landmarks[8].y;
    if (Math.abs(wristY - fingertipsY) > 0.3) {
        return 'wave';
    }

    return null;
}

// Show gesture indicator
function showGestureIndicator(gesture) {
    const indicator = document.getElementById('gestureIndicator');
    indicator.textContent = `Gesture Detected: ${gesture}`;
    indicator.style.display = 'block';
    setTimeout(() => {
        indicator.style.display = 'none';
    }, 2000);
}

// Initialize WebRTC
async function initializeCall() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
        });
        document.getElementById('localVideo').srcObject = localStream;

        socket = io('http://localhost:3000');
        socket.emit('join-room', roomId, userId);

        initializePeerConnection();
        initializeHandTracking();

        socket.on('user-connected', (userId) => {
            console.log('User connected:', userId);
            createOffer();
        });

        socket.on('gesture-received', (gesture) => {
            showGestureIndicator(`Received: ${gesture}`);
        });

    } catch (error) {
        console.error('Error initializing call:', error);
    }
}

function initializePeerConnection() {
    peerConnection = new RTCPeerConnection(iceServers);

    // Add local tracks to peer connection
    localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
    });

    // Handle incoming tracks
    peerConnection.ontrack = (event) => {
        document.getElementById('remoteVideo').srcObject = event.streams[0];
    };

    // ICE candidate handling
    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit('ice-candidate', event.candidate);
        }
    };

    socket.on('ice-candidate', (candidate) => {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    });
}

async function createOffer() {
    try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('offer', offer);
    } catch (error) {
        console.error('Error creating offer:', error);
    }
}

socket.on('offer', async (offer) => {
    try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('answer', answer);
    } catch (error) {
        console.error('Error handling offer:', error);
    }
});

socket.on('answer', async (answer) => {
    try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    } catch (error) {
        console.error('Error handling answer:', error);
    }
});

// Event Listeners
document.getElementById('startButton').addEventListener('click', initializeCall);
document.getElementById('muteButton').addEventListener('click', () => {
    const audioTrack = localStream.getAudioTracks()[0];
    audioTrack.enabled = !audioTrack.enabled;
    document.getElementById('muteButton').textContent = 
        audioTrack.enabled ? 'Mute' : 'Unmute';
});

document.getElementById('videoButton').addEventListener('click', () => {
    const videoTrack = localStream.getVideoTracks()[0];
    videoTrack.enabled = !videoTrack.enabled;
    document.getElementById('videoButton').textContent = 
        videoTrack.enabled ? 'Video Off' : 'Video On';
});